# 언리얼 엔진 개발자 취업 전략 노트

*2026년 2월 17일~20일 대화 정리*

---

## 1. "언리얼 개발자"라는 타이틀이 주는 인상

언리얼 엔진은 AAA 게임, 영화 VFX, 메타버스, 건축 시각화 등 업계 전반에 걸쳐 쓰이는 표준 툴이다. 이 때문에 언리얼 개발자라는 타이틀은 단순히 "게임 만드는 사람"이 아니라, 고퀄리티 실시간 3D 콘텐츠 전문가라는 이미지를 자연스럽게 얹어준다. 취업 마케팅에서 이 인식을 의식적으로 활용하는 것이 첫 번째 전략이다.

채용 담당자나 비기술직 임원이 "언리얼 개발자를 뽑는다"고 할 때 머릿속에 떠올리는 건 세 가지다. 트레일러나 컷신처럼 눈에 보이는 결과물을 뽑아내는 **비주얼 임팩트의 주체**, 팀 협업과 퍼포먼스 최적화 같은 프로세스 역량도 함께 갖춘 **대형 프로젝트 경험자**, 그리고 게임을 넘어 건축 시각화나 방송 가상 스튜디오 같은 분야에도 활용 가능한 **기술 범용성**이다. 특히 게임 업계 외 분야에서는 언리얼 개발자 수요가 있으면서도 경쟁이 훨씬 덜하다는 점이 포지션 선택의 폭을 넓혀준다.

기술 면접관이 보는 체크리스트는 훨씬 구체적이다. Blueprint만 쓸 수 있는 사람과 C++ 확장까지 가능한 사람은 사실상 다른 포지션이며, "이 기능은 Blueprint로 프로토타이핑하고, 퍼포먼스가 중요한 부분은 C++로 내렸다"는 식의 판단 근거를 설명할 수 있을 때 시니어 감각으로 읽힌다. 또한 GAS, Nanite, Lumen 같은 핵심 기술의 트레이드오프를 단순 사용법이 아닌 "왜 쓰고 어떤 비용이 따르는지"로 설명할 수 있어야 한다. 퍼포먼스 최적화 경험에서는 실제 수치(프레임 개선율, 메모리 절감량)를 언급할 수 있을 때 신뢰도가 올라간다.

---

## 2. CS 전공 주니어의 포지셔닝 전략

시각적 완성도는 아티스트의 영역이며, 프로그래머가 경쟁해야 할 곳이 아니다. 아트를 흉내내려다 둘 다 어중간해지는 것이 오히려 치명적이다. CS 전공 언리얼 프로그래머가 가져야 할 포지션은 명확하다.

> **"아티스트가 만든 것을 엔진 안에서 제대로 작동하게 만드는 사람"**

이것이 현실에서 팀이 가장 필요로 하는 역할이고, CS 전공자가 가장 잘할 수 있는 자리다.

아트-프로그래머 협업 현장에서는 아티스트가 혼자 해결하지 못하는 영역이 존재한다. 3만 폴리곤짜리 캐릭터가 들어왔을 때 60fps를 유지하려면 어떻게 해야 하는지, Nanite를 켜도 되는 상황인지, 셰이더 복잡도가 모바일 타겟에서 어떤 의미인지 — 이런 판단을 내리고 파이프라인에 녹여내는 것이 프로그래머의 일이다. 아티스트가 "이 이펙트가 왜 이렇게 보여요?"라고 물었을 때 Material 노드 구조를 설명해줄 수 있는 번역가 역할도 여기에 속한다.

CS 전공이 주는 실질적 무기는 세 가지다. 아트 출신 테크니컬 아티스트와 차이가 나는 **수학적 기반**(선형대수, 행렬 변환, 삼각함수 기반의 절차적 애니메이션이나 물리 시뮬레이션 구현), 게임플레이 시스템과 AI 상태 머신의 구조를 설계할 수 있는 **시스템 설계 감각**, 그리고 퍼포먼스 병목을 찾아내고 버그를 추적하는 **디버깅과 프로파일링 능력**이다. 이 세 가지는 아트 전공자가 독학으로 따라잡기 어려운 영역이다.

아트를 배우는 데 시간을 쓰는 대신, **아트 파이프라인을 이해**하는 것에 시간을 쓰는 편이 훨씬 효율적이다. Maya나 Blender에서 익스포트할 때 어떤 설정이 언리얼에서 문제가 되는지, UV 채널이 왜 중요한지, 텍스처 해상도와 메모리의 관계 — 이런 것을 알면 "FBX 익스포트할 때 스무딩 그룹 체크하셨어요?"라고 바로 물을 수 있고, 이 차이가 협업 현장에서 신뢰도를 만든다.

---

## 3. TA로 읽히는 함정을 피하는 법

머티리얼 시스템이나 Niagara를 깊이 파면 면접관은 자연스럽게 "이 사람은 TA 지원자구나"로 분류한다. TA와 게임플레이 프로그래머는 연봉 테이블도 역할도 다르기 때문에, 의도하지 않았다면 이 혼선은 치명적이다.

핵심은 **"무엇을 알고 있냐"가 아니라 "어디에 그 지식을 썼냐"**다. 셰이더 자체의 비주얼 결과물을 포트폴리오에 올리면 TA로 읽히지만, "아티스트가 넘겨준 머티리얼의 인스턴싱 구조가 드로우콜을 과하게 만들어서, C++로 Dynamic Material Instance 관리 시스템을 짜서 해결했다"는 식으로 서술하면 동일한 지식이 프로그래머의 문제 해결 경험으로 읽힌다.

아트 파이프라인 이해는 **프로그래밍 문제를 해결하기 위한 배경 지식**으로 포지셔닝하고, 전면에 내세우는 건 항상 시스템 설계, 퍼포먼스 개선, 게임플레이 로직 같은 코드 레벨의 결과물이어야 한다.

---

## 4. 중소 게임사 취업 준비 우선순위

중소 게임사는 대형 스튜디오처럼 직군을 칼같이 나누지 않고, 한 사람이 여러 역할을 커버하길 기대한다. "넓게 할 수 있는 사람"이 오히려 경쟁력이 된다.

**1순위는 게임플레이 프로그래밍 기반**이다. GameMode, GameState, PlayerState, PlayerController, Pawn 구조를 단순히 쓸 줄 아는 것을 넘어, 각각의 책임 범위와 네트워크상에서의 존재 위치를 설명할 수 있어야 한다. GAS(Gameplay Ability System)는 중소 게임사에서도 도입이 늘고 있어, "GAS 구조를 이해하고 프로젝트 도입을 검토해봤다"는 것만으로도 주니어 레벨에서 눈에 띈다.

**2순위는 팀 프로젝트 경험을 언어로 만드는 것**이다. 많은 주니어가 "팀 프로젝트 했어요" 수준으로만 제출한다. 면접관이 듣고 싶은 것은 "어떤 기술적 문제가 발생했고, 어떤 판단으로 어떻게 해결했으며, 그 결과가 프로젝트에 어떤 영향을 줬는지"라는 구조다. 버전 관리 방식, 브랜치 전략, 다른 직군과의 커뮤니케이션 방식도 자주 나오는 주제다.

**3순위는 최적화 기초 감각**이다. 중소 게임사는 전담 최적화 팀이 없어서 게임플레이 프로그래머가 퍼포먼스도 함께 신경 써야 하는 경우가 많다. Unreal Insights나 stat 명령어로 병목을 찾아본 경험, 틱 최적화나 오브젝트 풀링 같은 기본 패턴을 알고 있다는 것만으로 "현장 감각이 있는 사람"으로 읽힌다.

**4순위는 네트워크·멀티플레이 기초 개념**이다. 온라인 게임을 만드는 팀이라면 언리얼 Replication 기초를 아는 사람을 원한다. "서버 권위 구조와 클라이언트 예측이 뭔지 개념적으로 이해하고 있다"는 것만 말할 수 있어도 준비 시간 대비 인상 개선 효율이 높다.

---

## 5. 비주얼 퍼포먼스 문제와 프로그래머의 해결 방향

에셋 스토어 에셋을 소규모로 배치할 때는 문제가 없었더라도, 중-대규모로 치환하면 예측 가능한 문제 패턴이 있다. 이를 미리 이해하고 "측정 → 진단 → 해결"의 언어로 말할 수 있어야 면접관에게 매력 있게 보인다.

### 드로우콜 폭발 (Draw Call Overhead)

같은 건물 메시를 10개 배치할 때는 괜찮았지만 오픈월드에 100개를 배치하니 프레임이 반토막 나는 상황은, 각 메시가 독립적인 머티리얼 인스턴스를 갖고 있어 GPU가 100번의 그리기 명령을 받기 때문이다. CPU-GPU 통신 오버헤드가 병목이다. 프로그래머는 Instanced Static Mesh나 HISM(Hierarchical Instanced Static Mesh)으로 전환해 같은 메시를 한 번의 드로우콜로 여러 개 그리는 구조를 만들고, C++로 런타임에 HISM Component로 자동 변환하는 시스템을 구성한다. 면접에서는 `stat RHI`로 드로우콜 수를 확인하고 1200에서 300으로 줄여 40fps에서 60fps로 개선했다는 수치 중심의 서술이 효과적이다.

### 텍스처 메모리 초과 (Texture Streaming Budget)

4K 텍스처 에셋을 씬에 50개 넣었을 때 모바일에서 크래시가 발생하는 것은, 에셋 스토어 에셋의 텍스처 스트리밍 설정이 제대로 안 돼있어 VRAM을 초과하기 때문이다. 프로그래머는 Texture Streaming Pool 크기를 타겟 플랫폼 기준으로 재설정하고, Mip Map LOD Bias를 C++로 거리별 강제 조정하는 시스템을 구축한다. `stat Streaming`으로 메모리 사용량을 체크하고, 거리별 LOD 커브 조정으로 30% 메모리를 절감했다는 프로세스로 서술한다.

### 과도한 틱 부하 (Tick Overhead)

"흔들리는 나뭇잎" 블루프린트가 씬에 200개 있을 때 CPU 시간의 40%를 틱이 차지하는 것은, 블루프린트가 매 프레임 실행되는 인터프리터 오버헤드 때문이다. 틱이 필요 없는 오브젝트는 Tick Enabled를 끄고 타이머나 이벤트 기반으로 전환하며, 여러 오브젝트의 업데이트를 하나의 매니저 클래스에서 배치 처리하는 구조로 변경한다. Unreal Insights로 블루프린트 틱 오버헤드를 확인하고, 핵심 로직을 C++로 옮겨 CPU 시간 30% 절감했다는 식으로 표현한다.

### 셰이더 컴파일레이션 스톨 (Shader Compilation Stutter)

플레이 중 새로운 머티리얼이 화면에 등장할 때마다 0.5초씩 프레임이 멈추는 것은, 언리얼이 처음 보는 머티리얼을 런타임에 메인 스레드에서 셰이더 컴파일하기 때문이다. PSO(Pipeline State Object) 캐싱을 활성화해 빌드 시점에 미리 컴파일하고, 로딩 화면에서 씬 전환 시 필요한 머티리얼을 프리로드하는 시스템을 C++로 구현해 인게임 스터터를 제거한다.

### Nanite/Lumen 잘못된 사용

Nanite는 초고밀도 폴리곤에 최적화된 기술이며, 소형 오브젝트나 반투명 머티리얼, 스켈레탈 메시에 적용하면 오버헤드만 추가된다. Lumen 역시 정적 씬에서는 불필요한 계산만 유발한다. 프로그래머는 에셋을 폴리곤 수, 화면 비중, 머티리얼 타입으로 분류해 Nanite 사용 기준을 수립하고, 동적 조명이 필요한 공간에만 Lumen을 활성화하는 판단 기준을 제시한다.

---

## 6. 스스로 문제를 발견하는 진단 사고 흐름

현장에서는 아무도 "여기 드로우콜 문제야"라고 알려주지 않는다. 스스로 문제를 발견하고 진단하는 사고 흐름이 핵심 역량이다.

### Phase 1 — "뭔가 이상한데?"라는 감각 잡기

특정 맵 영역에서 프레임이 떨어지거나, 적이 많이 스폰되면 버벅이거나, 로딩 후 첫 몇 초가 불안정한 체감을 먼저 포착한다. 이 단계에서는 "왜?"를 묻지 말고 **"언제?"**만 기록한다. 재현 조건을 명확히 하는 것이 우선이다.

### Phase 2 — 콘솔 명령어로 1차 측정

`stat unit`을 입력하면 Frame, Game, Draw, GPU 각각의 밀리초 수치가 나온다. Draw와 GPU가 높으면 렌더링 문제, Game이 높으면 CPU 로직 문제다. `stat rhi`로 Draw calls 수를 확인하고, `profilegpu`로 BasePass, Shadows, Translucency 등 렌더 패스별 GPU 시간을 분석한다.

### Phase 3 — 시각화로 범인 잡기

뷰포트의 **Shader Complexity** 뷰 모드는 화면을 초록/노랑/빨강으로 보여주며, 빨간 곳이 과부하 구간이다. 파티클이나 투명 머티리얼이 빨갛다면 해당 머티리얼의 Instruction Count를 확인한다(300 이상이면 의심). `stat scenerendering`으로 Static mesh draw calls 수를 보고, 같은 메시가 반복 배치된 오브젝트를 Instanced Static Mesh로 교체해야 하는지 판단한다.

### Phase 4 — 틱 오버헤드 잡기 (CPU 병목)

`stat unit`에서 Game 시간이 높을 때 `stat game`으로 들어간다. 액터별 틱 시간이 나오며, 특정 블루프린트 인스턴스 수와 틱 시간의 곱이 병목의 원인임을 확인한다. 해당 블루프린트의 Event Tick에서 매 프레임 실행되는 불필요한 계산을 찾아 타이머 기반으로 전환한다.

### Phase 5 — 메모리 누수 의심

시간이 지날수록 프레임이 떨어지는 경우 `stat memory`와 `stat streaming`으로 확인한다. `Texture Streaming Pool: 1.8GB / 1.5GB (!!!)` 같은 한계 초과 신호가 보이면 텍스처가 계속 로드되되 언로드되지 않는 스트리밍 설정 문제를 의심한다.

### Phase 6 — Unreal Insights (정밀 프로파일링)

위 방법으로도 감이 안 잡히면 Tools → Session Frontend → Profiler에서 30초 캡처 후 분석한다. 타임라인에서 프레임 스파이크를 클릭하면 해당 프레임에서 시간을 많이 잡아먹은 함수 목록이 보이고, 특정 블루프린트의 ExecuteUbergraph를 추적해 범인을 특정할 수 있다.

### 진단 흐름 요약

```
체감 → "이 상황에서 느리다"
  ↓
stat unit → GPU/CPU 중 누가 범인?
  ↓
GPU 범인: stat rhi → profilegpu → Shader Complexity 뷰
CPU 범인: stat game → Unreal Insights
  ↓
특정 오브젝트/시스템 특정
  ↓
임시 수정 → 다시 측정 → 개선 확인
```

가장 강력한 디버깅 습관은 **"이거 끄면 어떻게 되지?"**다. 라이팅, 포스트 프로세스, 특정 액터를 하나씩 끄면서 프레임 변화를 관찰하면, 어느 시스템이 무거운지 자연스럽게 드러난다. 문제가 없었더라도 프로파일링 결과(드로우콜 150개, 평균 60fps 유지 등)를 데이터로 남겨두면 "측정하는 습관이 있는 사람"으로 읽힌다.

