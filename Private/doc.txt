언리얼 게임 개발자를 준비중인데 '나'를 기업에 마케팅하는 행위 (i.e., 구직/취업활동)에 있어서 뭔가 포인트가 될만한 메리트가 좀 있으면 좋겠어. 일반인의 시선에서 언리얼 엔진 기술자 를 바라볼때 기대하게 되는 작업의 범주라던가 개발자가 바라볼때의 기대요소 라던가 쓸만한 요점을 좀 잡아봐.

2월 17일
언리얼 엔진 개발자 취업 마케팅 포인트
핵심 전제: "언리얼 개발자"가 주는 인상
언리얼 엔진은 AAA 게임, 영화 VFX, 메타버스, 건축 시각화까지 쓰이는 업계 표준 툴이라는 인식이 강해서, 단순한 "게임 만드는 사람"이 아닌 고퀄리티 실시간 3D 콘텐츠 전문가라는 이미지를 자연스럽게 얹어줍니다. 이걸 의식적으로 활용하는 게 첫 번째 전략입니다.

일반 채용 담당자 시선에서의 기대값
채용 담당자나 비개발자 임원이 "언리얼 개발자 뽑는다"고 할 때 머릿속에 떠올리는 건 주로 이런 것들입니다.

비주얼 임팩트를 만드는 사람. 트레일러, 컷신, 쇼케이스 영상처럼 눈에 보이는 결과물을 뽑아내는 역할로 인식합니다. 포트폴리오에 플레이 영상이나 렌더링 결과물이 있으면 면접 전에 이미 절반은 설득된 상태로 들어옵니다.

대형 프로젝트 경험자. 언리얼 자체가 규모 있는 프로젝트에 쓰인다는 인식이 있어서, 팀 협업, 버전 관리, 퍼포먼스 최적화 같은 프로세스 역량도 함께 기대합니다. 혼자 만든 소규모 프로젝트라도 이런 키워드를 의식적으로 녹여두면 인상이 달라집니다.

기술 범용성. 게임 외에도 건축·인테리어 시각화, 자동차 디자인 리뷰, 방송 가상 스튜디오 같은 분야에서도 쓰인다는 걸 채용 담당자는 어렴풋이 알고 있습니다. 게임 회사 외에 광고·엔터·제조사 인하우스 팀에도 언리얼 개발자 수요가 있고, 이 쪽 포지션은 경쟁이 게임 업계보다 훨씬 덜합니다.

현직 개발자·기술 면접관 시선에서의 기대값
개발팀장이나 리드 프로그래머가 보는 체크리스트는 훨씬 구체적입니다.

C++ vs Blueprint 비율 이해. Blueprint만 쓸 수 있는 사람과 C++ 확장까지 가능한 사람은 사실상 다른 포지션입니다. 두 가지를 모두 다루면서 "이 기능은 Blueprint로 프로토타이핑하고 퍼포먼스가 중요한 부분은 C++로 내렸다"는 식의 판단 근거를 설명할 수 있으면 시니어 감각으로 봅니다.

엔진 내부 이해도. GAS(Gameplay Ability System), ECS 방향성인 Mass Entity, Nanite·Lumen 같은 렌더링 기술의 트레이드오프를 설명할 수 있는지 봅니다. 기능 사용법이 아니라 "왜 이걸 썼고 어떤 비용이 따르는지"를 말할 수 있어야 합니다.

퍼포먼스 최적화 경험. 드로콜 배칭, LOD 설정, 프로파일러(Unreal Insights) 활용 경험은 주니어와 미들을 가르는 기준선으로 자주 쓰입니다. 실제 수치(프레임 개선율, 메모리 절감량)를 언급할 수 있으면 신뢰도가 올라갑니다.

멀티플레이·네트워크 이해. 언리얼의 Replication 시스템과 GameState/PlayerState 구조를 이해하고 있으면 서비스 게임을 만드는 팀에서 바로 쓸 수 있는 사람으로 봅니다. 의외로 여기까지 파고 있는 지원자가 많지 않아서 차별점이 됩니다.

포지셔닝 전략 요약
결국 취업 마케팅에서 가장 효과적인 프레임은 두 가지입니다.

첫째, **"게임을 만드는 사람"이 아니라 "실시간 3D 경험을 설계하는 사람"**으로 자신을 정의하는 것. 지원할 수 있는 업종의 범위가 넓어지고 몸값의 기준점 자체가 달라집니다.

둘째, 포트폴리오에 의사결정 맥락을 담는 것. "이걸 만들었다"보다 "이런 문제가 있었고 이렇게 해결했으며 그 결과가 이렇다"는 구조로 작업을 설명하면, 기술 면접관에게는 사고방식을, 비기술 채용 담당자에게는 프로젝트 매니지먼트 역량을 동시에 보여줄 수 있습니다.

그럼 위의 요점들에서, 나는 컴퓨터공학과를 공부한 일개 주니어 프로그래머 수준이란말이지? 그런데 위의 요점들에 프로그래머 레벨이 어떻게 그려져야 좋을까? 예를들어서 시각적 완성도를 보여줘야한다면 내가 생각하기엔 3D미술 전공을 한 사람의 영역을 다시 공부해야할거같은데, 이건 너무 비현실적인 준비니까 그렇지만 내가 그런 다른 직군의 사람과 협업 함에 있어서 어떠한 메리트를 줄 수 있다는 그런 내용.

2월 17일
주니어 CS 전공자의 포지셔닝 전략
핵심 관점 전환
먼저 오해를 짚고 넘어가면, 시각적 완성도는 아티스트의 영역이고 당신이 경쟁해야 할 곳이 아닙니다. 채용 시장에서 프로그래머에게 "아트도 잘한다"를 기대하는 팀은 극소수의 인디 팀뿐이고, 그마저도 진짜 기대값은 낮습니다. 오히려 프로그래머가 아트를 흉내내려다 둘 다 어중간해지는 게 더 치명적입니다.

당신이 실제로 가져야 할 포지션은 이겁니다.

"아티스트가 만든 것을 엔진 안에서 제대로 작동하게 만드는 사람"

이게 현실에서 팀이 가장 필요로 하는 역할이고, CS 전공 프로그래머가 가장 잘할 수 있는 자리입니다.

협업 구도에서 프로그래머의 실제 가치
아트-프로그래머 협업 현장에서 실제로 발생하는 문제들을 보면 당신의 역할이 명확해집니다.

아티스트가 혼자 해결 못 하는 것들이 있습니다. 예를 들어 아티스트가 3만 폴리곤짜리 캐릭터를 들고 왔을 때 게임에서 60fps를 유지하려면 어떻게 해야 하는지, Nanite를 켜도 되는 상황인지 아닌지, 셰이더 복잡도가 모바일 타겟에서 어떤 의미인지 — 이런 판단을 내리고 실제로 파이프라인에 녹여내는 게 프로그래머의 일입니다.

아트와 코드 사이의 번역가 역할도 있습니다. 아티스트가 "이 이펙트가 왜 이렇게 보여요?"라고 물었을 때 Material 노드 구조를 설명해줄 수 있는 사람, 기획자가 "이 기능 가능해요?"라고 물었을 때 기술적 비용을 가늠해서 대안을 제시하는 사람 — 이게 팀 안에서 없어서는 안 되는 포지션입니다. 그리고 이건 순수 아트 전공자는 할 수 없습니다.

CS 전공이 주는 실질적 무기
아트 전공자가 독학으로 따라잡기 어려운 영역이 바로 당신의 강점입니다.

수학적 기반. 선형대수, 행렬 변환, 삼각함수 기반의 절차적 애니메이션이나 물리 시뮬레이션을 구현할 때, 아트 출신 테크니컬 아티스트와 CS 출신 프로그래머 사이에는 이해의 깊이 차이가 납니다. 셰이더 코드를 직접 짜거나 커스텀 물리 로직을 건드릴 때 이 차이가 드러납니다.

시스템 설계 감각. 게임플레이 시스템, 인벤토리, AI 상태 머신 같은 구조를 설계할 때 객체지향 설계나 데이터 구조에 대한 이해가 있는 사람과 없는 사람은 중장기적으로 유지보수 비용에서 극명하게 갈립니다. 이건 CS 전공자가 체계적으로 배운 영역입니다.

디버깅과 프로파일링. 버그를 추적하고 퍼포먼스 병목을 찾아내는 능력은 프로그래밍 훈련을 받은 사람이 압도적으로 유리합니다. 현장에서 이게 안 되면 팀 전체의 발목을 잡습니다.

현실적인 준비 방향
아트를 배우는 데 시간을 쓰는 대신, 아트 파이프라인을 이해하는 것에 시간을 쓰는 게 훨씬 효율적입니다. 구체적으로는 이런 것들입니다.

아티스트가 쓰는 툴의 워크플로우를 겉으로 이해하는 것 — Maya나 Blender에서 익스포트할 때 어떤 설정이 언리얼에서 문제가 되는지, UV 채널이 왜 중요한지, 텍스처 해상도와 메모리의 관계 같은 것들. 이걸 알면 아티스트와 대화할 때 "그거 UE에서 받아보면 알 것 같아요" 대신 "FBX 익스포트할 때 스무딩 그룹 체크하셨어요?"라고 바로 물을 수 있습니다. 이 차이가 협업 현장에서 신뢰도를 만듭니다.

또한 Technical Artist의 역할을 프로그래머 관점에서 흡수하는 것도 방향이 됩니다. 테크니컬 아티스트는 아트와 프로그래밍의 경계에 있는 포지션인데, CS 전공 프로그래머가 언리얼 머티리얼 시스템과 Niagara 파티클을 깊이 파면 이 포지션에 가까워집니다. 아트 실력 없이도 접근 가능한 영역이고, 수요에 비해 공급이 적은 포지션입니다.

한 줄 요약
아트를 잘하는 척할 필요도, 아트를 배울 필요도 없습니다. "아티스트와 기획자가 원하는 걸 실제로 엔진 안에서 구현하고 최적화할 수 있는 사람" — 이게 CS 전공 언리얼 프로그래머가 취업 시장에서 가질 수 있는 가장 정직하고 강력한 포지션입니다.

다만 위의 TA 파트의 요소들을 파고든다면 면접관 입장에서 바라볼때, 컨텐츠 프로그래머 등의 개발이 아니라 TA직군으로 바라보게 되지않을까

2월 18일
맞는 지적입니다. 그게 실제로 포지셔닝의 함정입니다.

머티리얼 시스템이나 Niagara를 깊게 파면 자연스럽게 "이 사람은 TA 지원자구나"로 읽힙니다. 특히 포트폴리오에 셰이더 결과물이나 파티클 이펙트가 전면에 나오면 면접관은 거의 자동으로 그쪽으로 분류합니다. TA와 게임플레이 프로그래머는 연봉 테이블도 다르고 팀 안에서의 역할도 다르기 때문에, 본인이 원하는 방향이 아니라면 이 혼선은 꽤 치명적입니다.

그러면 진짜 질문은 이겁니다. 아트 파이프라인을 이해하되 프로그래머로 읽히려면 무엇을 전면에 내세워야 하는가.

답은 결국 **"무엇을 알고 있냐"가 아니라 "어디에 그 지식을 썼냐"**로 귀결됩니다.

예를 들어 머티리얼 시스템을 안다는 걸 보여줄 때, 셰이더 자체의 비주얼 결과물을 포트폴리오에 올리면 TA로 읽힙니다. 반면 "아티스트가 넘겨준 머티리얼의 인스턴싱 구조가 드로콜을 과하게 만들어서 C++로 Dynamic Material Instance 관리 시스템을 짜서 해결했다"는 식으로 서술하면 동일한 지식이 프로그래머의 문제 해결 경험으로 읽힙니다. 맥락의 차이입니다.

즉 아트 파이프라인 이해는 프로그래밍 문제를 해결하기 위한 배경 지식으로 포지셔닝하고, 전면에 내세우는 건 항상 시스템 설계, 퍼포먼스 개선, 게임플레이 로직 같은 코드 레벨의 결과물이어야 합니다. 아트를 안다는 건 "그래서 이런 문제도 혼자 진단할 수 있다"는 부가 능력으로만 언급하는 게 맞습니다.

그럼 일단 비쥬얼적인 부분에서는 그렇게 작성하고, 나머지 다른 분야에 대해서는 어떤준비를 해야하는지?

2월 18일
좋은 질문인데, 방향을 잡기 전에 하나 먼저 확인하고 싶습니다.

"나머지 다른 분야"가 꽤 넓어서, 지금 어느 쪽으로 취업을 목표로 하는지에 따라 준비 내용이 많이 달라집니다.

질문: 목표 직군이 어느 쪽인가요?
답변: 아직 미정 / 둘 다 알고 싶음

질문: 목표 회사 규모는?
답변: 중소 게임사

질문: 현재 언리얼 실습 경험 수준은?
답변: 팀 프로젝트 경험 있음

2월 18일
좋습니다. 그러면 꽤 현실적인 그림을 그릴 수 있습니다.

중소 게임사 + 직군 미정이라는 조건이 사실 유리하게 작용합니다. 대형 스튜디오는 게임플레이/엔진/툴 프로그래머를 칼같이 나누지만, 중소 게임사는 한 사람이 여러 역할을 커버하길 기대하기 때문에 "넓게 할 수 있는 사람"이 오히려 경쟁력이 됩니다. 팀 프로젝트 경험이 있다는 것도 이미 이력서에 쓸 수 있는 실질적인 자산입니다.

그러면 준비해야 할 영역을 현실적인 우선순위로 정리하겠습니다.

1순위 — 게임플레이 프로그래밍 기반 다지기
중소 게임사에서 가장 먼저 투입되는 업무가 여기입니다. 팀 프로젝트 경험이 있다면 이미 일부는 해봤겠지만, 면접관이 검증하려는 포인트는 "만들어봤냐"가 아니라 "왜 그렇게 설계했냐"입니다.

구체적으로는 언리얼의 GameMode, GameState, PlayerState, PlayerController, Pawn 구조를 단순히 쓸 줄 아는 게 아니라 각각의 책임 범위와 네트워크 상에서의 존재 위치를 설명할 수 있어야 합니다. 그리고 GAS(Gameplay Ability System)는 중소 게임사에서도 쓰는 곳이 늘고 있어서, 개념 정도는 잡아두면 차별점이 됩니다. 깊게 구현까지 안 해도 "GAS 구조를 이해하고 프로젝트에 도입 검토해봤다"는 것만으로도 주니어 레벨에선 눈에 띕니다.

2순위 — 팀 프로젝트 경험을 "언어"로 만들기
이미 팀 프로젝트 경험이 있다는 게 이 단계에서 가장 중요한 자산입니다. 그런데 많은 주니어들이 이걸 "저 팀 프로젝트 했어요" 수준으로만 제출합니다. 면접관이 듣고 싶은 건 따로 있습니다.

팀에서 어떤 기술적 문제가 발생했고, 본인이 어떤 판단으로 어떻게 해결했으며, 그 결과가 프로젝트에 어떤 영향을 줬는지. 이 구조로 경험을 재구성해두는 게 준비의 핵심입니다. 버전 관리(Git + Perforce 중 어떤 걸 썼는지), 브랜치 전략, 다른 직군과의 커뮤니케이션 방식 같은 것도 중소 게임사 면접에서 자주 나오는 주제입니다.

3순위 — 최적화 기초 감각
중소 게임사는 대형 스튜디오처럼 전담 최적화 팀이 없기 때문에, 게임플레이 프로그래머가 퍼포먼스도 같이 신경 써야 하는 경우가 많습니다. Unreal Insights나 stat 명령어로 병목을 찾아본 경험, 틱 최적화나 오브젝트 풀링 같은 기본 패턴을 알고 있다는 것만으로도 "현장 감각이 있는 사람"으로 읽힙니다. 깊게 파지 않아도 되고, 팀 프로젝트에서 프레임 드랍 같은 문제를 만났던 경험이 있다면 그걸 어떻게 접근했는지 정리해두는 것만으로 충분합니다.

4순위 — 네트워크/멀티플레이 맛보기
당장 필수는 아니지만, 중소 게임사에서 온라인 게임을 만드는 팀이라면 언리얼 Replication 기초를 아는 사람을 원합니다. 멀티플레이를 완성해본 경험이 없어도 "서버 권위 구조와 클라이언트 예측이 뭔지 개념적으로 이해하고 있다"는 걸 말할 수 있으면 됩니다. 이건 준비 시간 대비 인상 개선 효율이 꽤 높은 영역입니다.

정리하면
지금 팀 프로젝트 경험이 있다는 건 사실 주니어 시장에서 꽤 유리한 출발점입니다. 지금 단계에서 새로운 걸 많이 쌓으려 하기보다, 이미 한 경험을 면접관의 언어로 재포장하는 작업이 취업 준비에서 가장 빠른 리턴을 줍니다. 그 위에 게임플레이 시스템 이해와 최적화 기초 감각을 올리는 순서가 현실적으로 가장 효율적인 루트입니다.

음. 여전히 비쥬얼 파트에서 내가 프로그래머로서 어떤 최적화를 할 수 있는지 에 대한 범주가 모호하고 잘 모르겠어. 내가 전혀 손대본적 없는 영역이라 무엇을 모르는지 조차 모르는 상황이야. 내가 했던 프로젝트에서 보통 에셋스토어 같은곳에서 돌아다니는 에셋들을 끌어다가 이것저것 배치하고 작동시켰고, 보통 규모가 작다보니 그만한 수준에서는 트러블슈팅 자체가 일어나지 않았단 말이지? 그럼 중-대규모로 치환했을때에 문제가 어느부분에서 생겨날것인지 예측 및 문제제기 를 할 수있는 지식이 있어야 할텐데 보통 어떤 이슈가 나오고 어떻게 해결하겠다는 방향을 제시해야 매력있지?

2월 20일
정확히 핵심을 찔렀습니다. "뭘 모르는지 모르는 상태"가 주니어가 가장 답답해하는 지점입니다. 그리고 면접관도 바로 그 지점을 테스트합니다 — "이 사람이 문제를 미리 예측할 수 있는가, 아니면 문제가 터져야 알아차리는가."

구체적인 문제 시나리오로 설명하겠습니다.

실제 현장에서 나오는 비주얼 관련 퍼포먼스 문제들
1. 드로우콜 폭발 (Draw Call Overhead)
문제 상황: 에셋 스토어에서 받은 건물 모델을 10개 배치했을 때는 괜찮았는데, 오픈월드 맵에 100개를 배치하니까 프레임이 반토막 났습니다.

원인: 각 메시가 독립적인 머티리얼 인스턴스를 갖고 있어서 GPU가 100번 그리기 명령을 받습니다. CPU-GPU 통신 오버헤드가 병목이 된 겁니다.

프로그래머의 해결 방향:

Instanced Static Mesh나 HISM(Hierarchical Instanced Static Mesh)로 전환해서 같은 메시를 한 번의 드로우콜로 여러 개 그리기
C++로 프로시저럴 배치 시스템을 짜서 런타임에 HISM Component로 자동 변환하는 구조 제작
머티리얼 파라미터를 동적으로 조정해야 한다면 Material Parameter Collection을 활용해 인스턴싱 유지
면접에서 말할 때는: "stat RHI 명령어로 드로우콜 수를 확인하고, 반복 배치되는 오브젝트는 인스턴싱으로 배칭했습니다. 결과적으로 드로우콜을 1200에서 300으로 줄여서 프레임을 40fps에서 60fps로 개선했습니다."

2. 텍스처 메모리 초과 (Texture Streaming Budget)
문제 상황: 아티스트가 4K 텍스처를 쓴 에셋들을 씬에 50개 넣었는데 모바일 기기에서 크래시가 납니다.

원인: 언리얼의 텍스처 스트리밍 시스템은 카메라 거리 기반으로 LOD를 조절하는데, 에셋 스토어 에셋은 이 설정이 제대로 안 돼있는 경우가 많습니다. 메모리에 4K 텍스처가 동시에 로드되면서 VRAM을 초과한 겁니다.

프로그래머의 해결 방향:

Texture Streaming Pool 크기를 프로파일링해서 타겟 플랫폼 기준으로 재설정
Mip Map LOD Bias를 C++로 거리별로 강제 조정하는 시스템 구축
중요하지 않은 오브젝트는 텍스처 그룹을 World나 WorldNormalMap으로 변경해서 스트리밍 우선순위 낮추기
면접에서 말할 때는: "stat Streaming으로 텍스처 메모리 사용량을 체크했고, 프로젝트 세팅에서 Texture Streaming Pool Size를 플랫폼별로 조정했습니다. 추가로 거리별 LOD 커브를 조정해 30% 메모리 절감했습니다."

3. 과도한 틱 부하 (Tick Overhead on Blueprints)
문제 상황: 에셋 스토어에서 받은 "흔들리는 나뭇잎" 블루프린트가 씬에 200개 있는데, 프로파일러 보니 이 블루프린트들의 틱이 CPU 시간의 40%를 먹고 있습니다.

원인: 블루프린트는 매 프레임마다 실행되는데(틱), 200개가 동시에 돌면 인터프리터 오버헤드가 누적됩니다. 특히 삼각함수 같은 계산이 들어가면 더 느립니다.

프로그래머의 해결 방향:

틱이 필요 없는 오브젝트는 Tick Enabled를 끄고 타이머나 이벤트 기반으로 전환
중요한 로직은 C++로 옮기고, 여러 오브젝트의 업데이트를 하나의 매니저 클래스에서 배치 처리
Wind Actor 같은 공통 데이터는 싱글톤 패턴으로 한 번만 계산하고 나머지는 그 결과를 참조만 하게 구조 변경
면접에서 말할 때는: "Unreal Insights로 프레임 분석했을 때 블루프린트 틱 오버헤드가 병목이었습니다. 불필요한 틱을 제거하고 핵심 로직을 C++로 옮겨서 CPU 시간 30% 절감했습니다."

4. 셰이더 컴파일레이션 스톨 (Shader Compilation Stutter)
문제 상황: 플레이 중에 새로운 머티리얼이 화면에 등장할 때마다 0.5초씩 프레임이 멈춥니다.

원인: 언리얼은 처음 보는 머티리얼을 만나면 런타임에 셰이더를 컴파일하는데, 이게 메인 스레드에서 일어나서 게임이 멈추는 겁니다. 특히 복잡한 머티리얼일수록 오래 걸립니다.

프로그래머의 해결 방향:

PSO(Pipeline State Object) 캐싱을 활성화해서 빌드 시점에 미리 컴파일
로딩 화면에서 UMaterialInstance::PreloadAllMaterialInstances() 같은 함수로 사용될 머티리얼 미리 로드
복잡한 머티리얼은 Quality Switch 노드로 플랫폼별 복잡도 분기 처리
면접에서 말할 때는: "셰이더 컴파일 히칭 문제를 PSO 캐싱으로 해결했고, 씬 전환 시 필요한 머티리얼을 프리로드하는 시스템을 C++로 구현해 인게임 스터터를 제거했습니다."

5. Nanite/Lumen 잘못된 사용 (Feature Misuse)
문제 상황: UE5의 Nanite를 켜면 퀄리티가 올라간다고 해서 모든 메시에 적용했는데 오히려 퍼포먼스가 떨어졌습니다.

원인: Nanite는 초고밀도 폴리곤에 최적화된 기술이고, 작은 오브젝트나 반투명 머티리얼, 스켈레탈 메시에는 오버헤드만 추가합니다. Lumen도 동적 조명이 필요 없는 정적 씬에서는 불필요한 계산만 합니다.

프로그래머의 해결 방향:

에셋을 폴리곤 수, 화면 비중, 머티리얼 타입으로 분류해서 Nanite 사용 기준 수립
정적 조명 씬에는 Lumen 대신 Lightmass로 베이크드 라이팅 사용
프로젝트 세팅에서 Nanite Fallback Percentage 같은 파라미터 조정
면접에서 말할 때는: "Nanite는 1만 폴리곤 이상 대형 메시에만 적용하고, 소형 props는 일반 스태틱 메시로 유지해서 GPU 오버헤드를 줄였습니다. Lumen은 동적 조명이 필요한 실내 공간에만 활성화했습니다."

핵심은 "측정 → 진단 → 해결"의 언어
위 사례들의 공통점은 모두 **측정 도구(stat 명령어, Unreal Insights, GPU Visualizer)**를 써서 문제를 수치로 확인했다는 점입니다. 면접관이 듣고 싶은 건 "이렇게 하면 빨라진다더라"가 아니라 "이 도구로 측정했을 때 이 부분이 병목이었고, 이렇게 수정해서 X% 개선했다"는 구체적 프로세스입니다.

지금 당장 할 수 있는 준비는, 본인이 했던 팀 프로젝트에서 위 도구들을 한 번이라도 돌려보고 결과를 스크린샷으로 남겨두는 겁니다. 문제가 없었더라도 "프로파일링 결과 드로우콜 150개, 평균 60fps 유지"라는 데이터만 있어도 "측정하는 습관이 있는 사람"으로 읽힙니다.

아. 지금은 내가 너를 통해서 문제-해결 의 쌍으로 바로 캐치가 가능하지만, 너가 없다는 상황을 가정한다면 내가 스스로 문제점을 맞닥뜨리고 그걸 진단하면서 '이게 이렇게 되서 문제가 되는구나' 를 깨닫게 되는 그 과정을 적고싶어. 어떤 진단도구와 어떤 생각의 흐름으로 그 문제를 바라보게 되는지를 알려줘.

2월 20일
정확합니다. 지금 필요한 건 "답"이 아니라 "어떻게 문제를 발견하는 사고 흐름" 그 자체입니다. 실제 현장에서는 아무도 "여기 드로우콜 문제야"라고 안 알려주니까요.

실전 진단 프로세스를 단계별로 풀어보겠습니다.

Phase 1: "뭔가 이상한데?"라는 감각 잡기
시작점 — 플레이 테스트 중 위화감
게임을 실행하고 돌아다니는데 특정 상황에서 뭔가 버벅인다는 느낌을 먼저 포착해야 합니다. 이게 출발점입니다.

예시 상황들:

특정 맵 영역에 들어가면 프레임이 뚝 떨어짐
적이 많이 스폰되면 버벅임
파티클 이펙트가 터질 때 순간 멈칫함
로딩은 빠른데 게임 시작 후 첫 몇 초가 불안정함
이 단계에서는 "왜?"를 묻지 말고 "언제?"만 기록합니다. 재현 조건을 명확히 하는 게 우선입니다.

Phase 2: 콘솔 명령어로 1차 측정
이제 에디터에서 플레이(PIE)하면서 물티 물어보기 시작합니다. 언리얼의 stat 명령어들은 대화 상대입니다.

첫 질문: "전체적으로 어디가 느린가?"
콘솔에 입력:

stat unit
화면 우측 상단에 이런 숫자들이 뜹니다:

Frame: 33.2ms (30fps)
Game: 8.5ms
Draw: 22.1ms
GPU: 24.3ms
사고 흐름:

Frame이 33ms면 30fps라는 뜻 (60fps 목표면 16.6ms 이하여야 함)
Draw(22.1ms)와 GPU(24.3ms)가 높다 → 렌더링 문제구나
Game(8.5ms)은 괜찮다 → 게임 로직은 일단 용의선상에서 제외
만약 Game 숫자가 높았다면 (예: 18ms) → CPU 로직 문제로 방향 전환

두 번째 질문: "렌더링 뭐가 무거운가?"
stat rhi
엄청 많은 숫자가 나오는데, 핵심만 봅니다:

Triangles drawn: 5,234,098
Draw calls: 1,847
사고 흐름:

Draw calls 1800번? → 배칭이 안 되고 있구나
보통 모바일은 200~500, PC는 1000 이하가 목표
"같은 메시를 여러 번 그리는 상황"을 의심
여기서 추가 실험: 씬의 특정 오브젝트들을 임시로 숨기면서 Draw call 변화 관찰

나무 200그루 숨김 → Draw call 1200으로 감소 → 범인 찾음
세 번째 질문: "GPU가 뭘 그리느라 바쁜가?"
profilegpu
카테고리별 GPU 시간이 나옵니다:

BasePass: 12.4ms
Shadows: 8.2ms
Lighting: 3.1ms
Translucency: 2.8ms
PostProcessing: 1.5ms
사고 흐름:

BasePass가 12ms나 잡아먹음 → 불투명 메시 그리기가 병목
Shadows도 8ms → 그림자 캐스팅이 과하구나
추가 실험:

r.Shadow.MaxResolution 512
입력해서 그림자 해상도 낮추기 → 프레임 개선되면 그림자가 문제 확정

Phase 3: 시각화로 범인 잡기
숫자만 보면 감이 안 올 때, "눈으로 보여줘" 모드들을 씁니다.

"셰이더가 복잡한 곳 찾기"
뷰포트 좌측 상단 View Mode → Optimization Viewmodes → Shader Complexity

화면이 초록/노랑/빨강으로 변합니다:

초록 = 가벼움
빨강 = 과부하
사고 흐름:

저 파티클이 빨간색으로 타오른다 → 파티클 머티리얼이 너무 복잡함
투명한 유리창이 빨갛다 → Translucent 머티리얼이 과하게 계산 중
여기서 문제 파일 특정: 해당 머티리얼 더블클릭 → 노드 복잡도 확인 → Instruction Count 숫자 체크 (300 이상이면 의심)

"드로우콜 어디서 터지나 찾기"
stat scenerendering
화면에 온갖 숫자가 나오는데, 이것만 봅니다:

Mesh draw calls: 1,203
Static mesh draw calls: 987
사고 흐름:

Static mesh가 987번 그려진다 → 인스턴싱이 안 된 메시들이 많구나
씬 아웃라이너에서 같은 메시 여러 개 배치된 거 검색 → Instanced Static Mesh Component로 교체 필요
Phase 4: 틱 오버헤드 잡기 (CPU 병목)
만약 stat unit에서 Game 시간이 높았다면 (예: 20ms) 이 루트로 갑니다.

stat game
액터들의 틱 시간이 나옵니다:

BP_TreeSwaying: 8.2ms (200 instances)
BP_EnemyAI: 5.1ms (50 instances)
사고 흐름:

TreeSwaying 블루프린트 200개가 8ms? → 하나당 0.04ms인데 200개 누적되면 병목
해당 블루프린트 열어보기 → Event Tick에 매 프레임 Sin 계산 발견 → 불필요한 틱
실험:

블루프린트에서 Tick Enabled 체크 해제 → 프레임 올라감 → 확정
해결 방향: 타이머로 0.1초마다 한 번만 업데이트하게 변경
Phase 5: 메모리 누수 의심 (시간 지날수록 느려지는 경우)
게임을 10분 돌렸더니 처음엔 60fps였는데 지금은 30fps로 떨어진 상황.

stat memory
Physical Memory: 3.2GB / 8GB
Texture Streaming Pool: 1.8GB / 1.5GB (!!!)
사고 흐름:

Texture Streaming Pool이 한계치 초과 → 텍스처가 계속 로드되는데 언로드는 안 됨
메모리 누수나 스트리밍 설정 문제
추가 명령어:

stat streaming
Streaming textures: 1,247 (Too many!)
범인 찾기:

프로젝트 세팅 → Texture Streaming 항목들 확인
Never Stream 체크된 텍스처들이 많으면 수동으로 메모리 점유 중
Phase 6: Unreal Insights (진지한 프로파일링)
위 방법들로도 감이 안 잡히면 녹화 후 분석 도구를 씁니다.

에디터 상단 → Tools → Session Frontend → Profiler 탭 → Capture 클릭

30초 정도 플레이하고 Stop → 타임라인 형태로 모든 함수 호출 시간이 보입니다.

사고 흐름:

타임라인에서 프레임 스파이크(툭 튀어나온 막대) 클릭
해당 프레임에서 시간 많이 잡아먹은 함수 목록 확인
AActor::Tick 안에 있는 BP_MyActor::ExecuteUbergraph 발견 → 해당 블루프린트가 범인
이제 그 블루프린트 열어서 해당 로직 최적화.

실전 사고 흐름 요약
1. 체감 → "이 맵 영역에서 느리다"
   ↓
2. stat unit → GPU/CPU 중 누가 범인?
   ↓
3-A. GPU 범인이면:
   - stat rhi → Draw call 체크
   - profilegpu → 어느 렌더 패스가 무거운지
   - Shader Complexity 뷰 → 빨간 곳 찾기
   
3-B. CPU 범인이면:
   - stat game → 어느 액터가 틱 많이 먹나
   - Unreal Insights → 함수 단위로 파고들기
   ↓
4. 특정 오브젝트/시스템 특정 완료
   ↓
5. 임시 수정 → 다시 측정 → 개선 확인
마지막 팁: "비교" 습관
문제를 찾을 때 가장 강력한 방법은 **"이거 끄면 어떻게 되지?"**입니다.

라이팅 끄기: r.LightingMode 0
포스트 프로세스 끄기: show postprocessing
특정 액터 타입 숨기기: 아웃라이너에서 체크 해제
하나씩 끄면서 프레임 변화를 보면, 어느 시스템이 무거운지 자연스럽게 드러납니다.

이 흐름이 몸에 배면, 누가 알려주지 않아도 스스로 문제를 발견하고 진단할 수 있는 개발자가 됩니다. 그리고 면접에서도 "이런 도구로 측정해봤고, 이 부분이 병목이었고, 이렇게 접근했습니다"라는 구조로 자연스럽게 말할 수 있게 됩니다.

